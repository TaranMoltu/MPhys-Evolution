%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% noiseplot.m
% Author: M. Williams 2/10/12
% This file reads in data generated by our C++ project and outputs a graph
% based on figure 1 of Rogers et al. It then does this in the form of a 
% grayscale histogram.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

filename = input('What is the filename for the data including extension?: ');
datamatrix = csvread(filename);

%We have now read in the data to the matrix datamatrix. Next we want to
%plot these. Going down in datamatrix (increasing rows) means a new
%discrete value of time. Going across in a row are all the heights in that
%time period.

i = 1; %counter for while expression

[rows, cols] = size(datamatrix); %rows is number of rows etc
hold on; %Ensure everything is plotted on one graph

%Now use two for loops to plot a graph. Note the commented out code is just
%debugging loops.
while i<=rows
    %fprintf('In outer loop. i is %6.2f.\n',i);
    j=1;
    while j<=cols
        %fprintf('In inner loop. j is %6.2f.\n',j);
        %fprintf('%6.2f.\n',datamatrix(i,j));
        plot(datamatrix(i,j), i-1, '-o'); %Use i-1 so first time step is t=0
        j=j+1;
    end
    i=i+1;
end
xlabel('Time');
ylabel('x');
hold off;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The basic functionality of plotting the value x (height in our example)
% vs time is now implemented. We now want to start implementing histogram
% functionality. To do this, we examine each generation and work out how
% many fit in a 'bucket'. We know that the range of values is from -pi to
% pi so we can ask the user how many buckets they want and divide the range
% up. Then count how many fall into a bucket.
% Useful to know: buckets = number of buckets wanted by user
% bucketsize = the size per bucket
% bucketmax = a vector showing how far across to go for each bucket
%
% TODO: (optional) range assumed is -pi to pi, we could implement option
% for user to enter min and max.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

buckets = input('How many buckets would you like to use? ');
bucketsize = (2*pi)/buckets;

%Declare max size for first bucket outside loop
bucketmax(1)= (-1*pi)+bucketsize;

%Note that this loop may cause bucketmax(buckets), the last bucket to be
%greater than pi due to rounding errors - this is not a huge problem
for n=2:buckets
   bucketmax(n) = bucketmax(n-1)+bucketsize;
end

%Now with the size of each bucket known we need to start the count of the
%number of values that fall in each bucket per generation.
%bucketmatrix is a matrix that has as many across as there are buckets and
%down as generations. The number in each cell represents the number of
%cells fitting in the range defined in bucketmax. Going across means bigger
%range, going down means further time step.
bucketmatrix = zeros(rows, buckets);
for i=1:rows
    for j=1:cols
        for k=1:buckets
            if k==1
                if -1*pi<=datamatrix(i,j) && datamatrix(i,j)<bucketmax(k)
                    bucketmatrix(i,k) = bucketmatrix(i,k)+1;
                end
            else
                if bucketmax(k-1)<=datamatrix(i,j) && datamatrix(i,j)<bucketmax(k);
                    bucketmatrix(i,k)= bucketmatrix(i,k)+1;
                end
            end
        end
    end
end



%To get greyscale value, work out percentage and times by 255